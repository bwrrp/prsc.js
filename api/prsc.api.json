{
  "metadata": {
    "toolPackage": "@microsoft/api-extractor",
    "toolVersion": "7.19.2",
    "schemaVersion": 1004,
    "oldestForwardsCompatibleVersion": 1001,
    "tsdocConfig": {
      "$schema": "https://developer.microsoft.com/json-schemas/tsdoc/v0/tsdoc.schema.json",
      "noStandardTags": true,
      "tagDefinitions": [
        {
          "tagName": "@alpha",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@beta",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@defaultValue",
          "syntaxKind": "block"
        },
        {
          "tagName": "@decorator",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@deprecated",
          "syntaxKind": "block"
        },
        {
          "tagName": "@eventProperty",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@example",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@experimental",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@inheritDoc",
          "syntaxKind": "inline"
        },
        {
          "tagName": "@internal",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@label",
          "syntaxKind": "inline"
        },
        {
          "tagName": "@link",
          "syntaxKind": "inline",
          "allowMultiple": true
        },
        {
          "tagName": "@override",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@packageDocumentation",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@param",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@privateRemarks",
          "syntaxKind": "block"
        },
        {
          "tagName": "@public",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@readonly",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@remarks",
          "syntaxKind": "block"
        },
        {
          "tagName": "@returns",
          "syntaxKind": "block"
        },
        {
          "tagName": "@sealed",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@see",
          "syntaxKind": "block"
        },
        {
          "tagName": "@throws",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@typeParam",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@virtual",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@betaDocumentation",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@internalRemarks",
          "syntaxKind": "block"
        },
        {
          "tagName": "@preapproved",
          "syntaxKind": "modifier"
        }
      ],
      "supportForTags": {
        "@alpha": true,
        "@beta": true,
        "@defaultValue": true,
        "@decorator": true,
        "@deprecated": true,
        "@eventProperty": true,
        "@example": true,
        "@experimental": true,
        "@inheritDoc": true,
        "@internal": true,
        "@label": true,
        "@link": true,
        "@override": true,
        "@packageDocumentation": true,
        "@param": true,
        "@privateRemarks": true,
        "@public": true,
        "@readonly": true,
        "@remarks": true,
        "@returns": true,
        "@sealed": true,
        "@see": true,
        "@throws": true,
        "@typeParam": true,
        "@virtual": true,
        "@betaDocumentation": true,
        "@internalRemarks": true,
        "@preapproved": true
      }
    }
  },
  "kind": "Package",
  "canonicalReference": "prsc!",
  "docComment": "",
  "name": "prsc",
  "members": [
    {
      "kind": "EntryPoint",
      "canonicalReference": "prsc!",
      "name": "",
      "members": [
        {
          "kind": "Function",
          "canonicalReference": "prsc!complete:function(1)",
          "docComment": "/**\n * Creates a parser that applies the given parser and only succeeds (returning the inner parser's result) if parsing concludes at the end of the input string.\n *\n * @param parser - The parser to wrap\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function complete<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "complete"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!consume:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given parser but discards the resulting value.\n *\n * @param parser - Parser to apply\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function consume<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "consume"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!cut:function(1)",
          "docComment": "/**\n * Creates a parser that turns errors returned by the inner parser into fatal errors. Parsers such as `or` and `star` will not continue to attempt additional matches if a parser returns a fatal error, and will usually return the error instead.\n *\n * @param parser - The parser to wrap\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function cut<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "cut"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!delimited:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given parsers in sequence, returning the result value of the middle parser at the offset of the third if all are successful. If any parser fails, the error is returned as-is.\n *\n * Optionally makes errors by the second and third parsers fatal if `cutAfterOpen` is `true`.\n *\n * @param open - First parser to apply, value is discarded\n *\n * @param inner - Second parser to apply, value is kept\n *\n * @param close - Third parser to apply, value is discarded\n *\n * @param cutAfterOpen - If `true`, errors returned by the second and third parsers are considered fatal, causing parsers using this to stop trying other branches.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function delimited<TOpen, T, TClose>(open: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<TOpen>"
            },
            {
              "kind": "Content",
              "text": ", inner: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ", close: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<TClose>"
            },
            {
              "kind": "Content",
              "text": ", cutAfterOpen?: "
            },
            {
              "kind": "Content",
              "text": "boolean"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 12,
            "endIndex": 14
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "open",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "parameterName": "inner",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              }
            },
            {
              "parameterName": "close",
              "parameterTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 9
              }
            },
            {
              "parameterName": "cutAfterOpen",
              "parameterTypeTokenRange": {
                "startIndex": 10,
                "endIndex": 11
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "TOpen",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "TClose",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "delimited"
        },
        {
          "kind": "Variable",
          "canonicalReference": "prsc!end:var",
          "docComment": "/**\n * A parser that only succeeds if the end of the input string is reached.\n *\n * @param input - The input to match in\n *\n * @param offset - The offset in `input` at which to start matching\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "end: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            }
          ],
          "releaseTag": "Public",
          "name": "end",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!error:function(1)",
          "docComment": "/**\n * Creates an unsuccessful ParseResult (parse error) at the given offset.\n *\n * @param offset - The offset in the input at which matching failed\n *\n * @param expected - An array of strings indicating things that were expected at offset\n *\n * @param fatal - If true, no other branches should be tried as a result of this error\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function error<T>(offset: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ", expected: "
            },
            {
              "kind": "Content",
              "text": "string[]"
            },
            {
              "kind": "Content",
              "text": ", fatal?: "
            },
            {
              "kind": "Content",
              "text": "boolean"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "ParseResult",
              "canonicalReference": "prsc!ParseResult:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 7,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "offset",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "parameterName": "expected",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            },
            {
              "parameterName": "fatal",
              "parameterTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 6
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "error"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!except:function(1)",
          "docComment": "/**\n * Creates a Parser that matches only if the first Parser matches input at the starting position, but the second Parser does not.\n *\n * @param match - Parser that should match\n *\n * @param except - Parser that should not match\n *\n * @param expected - Expected values for parse errors generated when the except parser succeeds\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function except<T, U>(match: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ", except: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<U>"
            },
            {
              "kind": "Content",
              "text": ", expected: "
            },
            {
              "kind": "Content",
              "text": "string"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 9,
            "endIndex": 11
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "match",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "parameterName": "except",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              }
            },
            {
              "parameterName": "expected",
              "parameterTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 8
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "U",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "except"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!filter:function(1)",
          "docComment": "/**\n * Creates a Parser that uses the given filter predicate to check values generated by the given parser. Values that pass the predicate are passed through, those that don't return a parse error instead.\n *\n * @param parser - Parser to filter\n *\n * @param filter - Predicate function over the inner parser's values\n *\n * @param expected - Expected values for parse errors generated when the filter rejects a value\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function filter<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ", filter: "
            },
            {
              "kind": "Content",
              "text": "(v: T) => boolean"
            },
            {
              "kind": "Content",
              "text": ", expected: "
            },
            {
              "kind": "Content",
              "text": "string[]"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 8,
            "endIndex": 10
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "parameterName": "filter",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              }
            },
            {
              "parameterName": "expected",
              "parameterTypeTokenRange": {
                "startIndex": 6,
                "endIndex": 7
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "filter"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!filterUndefined:function(1)",
          "docComment": "/**\n * Creates a parser that discards undefined values from the array produced by the given parser.\n *\n * Useful in combination with `star`, `or` and `consume`:\n * ```\n * const a: Parser<string> = token('a');\n * const b: Parser<void> = consume(token('b'));\n * const abs: Parser<(string | void)[]> = star(or<string | void>([a, b]));\n * const as: Parser<string[]> = filterUndefined(abs);\n * ```\n *\n * @param parser - Parser to apply, should produce an array that may contain undefined entries.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function filterUndefined<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<(T | void)[]>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T[]>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "filterUndefined"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!first:function(1)",
          "docComment": "/**\n * Returns the first of the given two arguments. Useful as a `join` function for `then`. See also `followed`.\n *\n * @param x - Argument to return\n *\n * @param y - Argument to ignore\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function first<T1, T2>(x: "
            },
            {
              "kind": "Content",
              "text": "T1"
            },
            {
              "kind": "Content",
              "text": ", y: "
            },
            {
              "kind": "Content",
              "text": "T2"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Content",
              "text": "T1"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "x",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "parameterName": "y",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T1",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "T2",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "first"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!followed:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result value of the first at the offset of the second if both succeed. If either parser fails the error is returned as-is.\n *\n * Equivalent to `then(parser, after, first)`.\n *\n * @param parser - First parser to apply, value is kept\n *\n * @param before - Second parser to apply, value is discarded\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function followed<T, TAfter>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ", after: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<TAfter>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 7,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "parameterName": "after",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "TAfter",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "followed"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!map:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given function to each value generated by the given parser.\n *\n * @param parser - Parser to map over\n *\n * @param map - Function to transform values generated by parser\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function map<T, U>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ", map: "
            },
            {
              "kind": "Content",
              "text": "(v: T) => U"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<U>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "parameterName": "map",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "U",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "map"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!not:function(1)",
          "docComment": "/**\n * Creates a parser that succeeds at the starting offset if the given parser fails and vice-versa.\n *\n * @param parser - The parser to apply\n *\n * @param expected - Expected values for parse errors generated when the inner parser succeeds\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function not<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ", expected: "
            },
            {
              "kind": "Content",
              "text": "string[]"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "parameterName": "expected",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "not"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!ok:function(1)",
          "docComment": "/**\n * Creates a successful ParseResult with an undefined value. Use this to signal success in cases where no value is required.\n *\n * @param offset - The offset in the input at which to continue parsing\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function ok(offset: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "ParseResult",
              "canonicalReference": "prsc!ParseResult:type"
            },
            {
              "kind": "Content",
              "text": "<undefined>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "offset",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            }
          ],
          "name": "ok"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!okWithValue:function(1)",
          "docComment": "/**\n * Creates a successful ParseResult containing the given value.\n *\n * @param offset - The offset in the input at which to continue parsing\n *\n * @param value - The value resulting from applying the parser\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function okWithValue<T>(offset: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ", value: "
            },
            {
              "kind": "Content",
              "text": "T"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "ParseResult",
              "canonicalReference": "prsc!ParseResult:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "offset",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "parameterName": "value",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "okWithValue"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!optional:function(1)",
          "docComment": "/**\n * Creates a parser that tries to apply the given parser optionally. It returns the inner parser's result if succesful, and otherwise indicates success at the starting offset with a `null` value.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @param parser - Parser to attempt to apply\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function optional<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T | null>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "optional"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!or:function(1)",
          "docComment": "/**\n * Creates a parser that applies each of the given parsers in turn until one matches, then returns that parser's result. If no parser matches, an error is returned reflecting the furthest offset reached in the input string. If any parser returns a fatal error, no further branches are tried.\n *\n * @param parsers - Parsers to attempt to apply\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function or<T>(parsers: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>[]"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parsers",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "or"
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "prsc!Parser:type",
          "docComment": "/**\n * A parser is a function that tries to match whatever it expects at the given offset in the input string. Returns a ParseResult.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare type Parser<T> = "
            },
            {
              "kind": "Content",
              "text": "(input: string, offset: number) => "
            },
            {
              "kind": "Reference",
              "text": "ParseResult",
              "canonicalReference": "prsc!ParseResult:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "releaseTag": "Public",
          "name": "Parser",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 4
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "prsc!ParseResult:type",
          "docComment": "/**\n * The result of parsing - either success (with an offset at which to resume parsing the next thing) or failure. If a failure is fatal, parsing should not continue to try alternative options.\n *\n * A ParseResult may contain a value that represents the parsed input.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare type ParseResult<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    success: true;\n    offset: number;\n    value: T;\n} | {\n    success: false;\n    offset: number;\n    expected: string[];\n    fatal: boolean;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "releaseTag": "Public",
          "name": "ParseResult",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!peek:function(1)",
          "docComment": "/**\n * Creates a parser that applies the given parser without consuming any input. That is, if the inner parser is successful, success is returned (with the resulting value) at the starting offset, effectively making the parser consume no input.\n *\n * Errors returned by the inner parser are returned as-is.\n *\n * @param parser - The parser to apply, value is discarded and any progress made in input is reset.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function peek<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "peek"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!plus:function(1)",
          "docComment": "/**\n * Creates a parser that tries to apply the given parser one or more times in sequence. Values for successful matches are collected in an array. Once the inner parser no longer matches, success is returned at the offset reached with the accumulated values. The parser is required to match at least once, so an initial failure is returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @param parser - The parser to apply repeatedly\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function plus<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T[]>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "plus"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!preceded:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result of the second if the first succeeds.\n *\n * Equivalent to `then(before, parser, second)`.\n *\n * @param before - First parser to apply, value is discarded\n *\n * @param parser - Second parser to apply, value is kept\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function preceded<TBefore, T>(before: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<TBefore>"
            },
            {
              "kind": "Content",
              "text": ", parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 7,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "before",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "TBefore",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "preceded"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!range:function(1)",
          "docComment": "/**\n * Creates a Parser that matches a single character from a range of codepoints.\n *\n * @param firstCodePoint - The first code point to accept\n *\n * @param lastCodePoint - The last code point to accept (inclusive)\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function range(firstCodePoint: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ", lastCodePoint: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<string>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "firstCodePoint",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "parameterName": "lastCodePoint",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "name": "range"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!recognize:function(1)",
          "docComment": "/**\n * Creates a parser that applies the given parser. If successful, the inner parser's value is discarded and the substring that was consumed from the input is returned as value instead. Errors are returned as-is.\n *\n * @param parser - The parser to apply, value is discarded and replaced by the consumed input.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function recognize<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<string>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "recognize"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!second:function(1)",
          "docComment": "/**\n * Returns the second of the given two arguments. Useful as a `join` function for `then`. See also `preceded`.\n *\n * @param x - Argument to ignore\n *\n * @param y - Argument to return\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function second<T1, T2>(x: "
            },
            {
              "kind": "Content",
              "text": "T1"
            },
            {
              "kind": "Content",
              "text": ", y: "
            },
            {
              "kind": "Content",
              "text": "T2"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Content",
              "text": "T2"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "x",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            },
            {
              "parameterName": "y",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T1",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "T2",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "second"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!skipChars:function(1)",
          "docComment": "/**\n * Creates a Parser that skips the given number of characters.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * @param nCodepoints - number of characters to skip\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function skipChars(nCodepoints: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "nCodepoints",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            }
          ],
          "name": "skipChars"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!star:function(1)",
          "docComment": "/**\n * Creates a parser that tries to apply the given parser zero or more times in sequence. Values for successful matches are collected in an array. Once the inner parser no longer matches, success is returned at the offset reached with the accumulated values.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @param parser - Parser to apply repeatedly\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function star<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T[]>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "star"
        },
        {
          "kind": "Variable",
          "canonicalReference": "prsc!start:var",
          "docComment": "/**\n * A parser that only succeeds at the start of the input string.\n *\n * @param input - The input to match in\n *\n * @param offset - The offset in `input` at which to start matching\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "start: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            }
          ],
          "releaseTag": "Public",
          "name": "start",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!then:function(1)",
          "docComment": "/**\n * Creates a parser that applies the given two parsers in sequence, returning success only if both succeed. The given join function is used to combine the values from both parsers into the single value to return. If either parser fails, the failure is returned as-is.\n *\n * @param parser1 - First parser to apply\n *\n * @param parser2 - Parser to apply after the first one is successful\n *\n * @param join - Function used to combine the values of both parsers\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function then<T1, T2, T>(parser1: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T1>"
            },
            {
              "kind": "Content",
              "text": ", parser2: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T2>"
            },
            {
              "kind": "Content",
              "text": ", join: "
            },
            {
              "kind": "Content",
              "text": "(value1: T1, value2: T2) => T"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 9,
            "endIndex": 11
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser1",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              }
            },
            {
              "parameterName": "parser2",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              }
            },
            {
              "parameterName": "join",
              "parameterTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 8
              }
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T1",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "T2",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "then"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!token:function(1)",
          "docComment": "/**\n * Creates a Parser that matches the given string.\n *\n * @param token - The expected string\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function token(token: "
            },
            {
              "kind": "Content",
              "text": "string"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<string>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "token",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              }
            }
          ],
          "name": "token"
        }
      ]
    }
  ]
}
