{
  "metadata": {
    "toolPackage": "@microsoft/api-extractor",
    "toolVersion": "7.25.1",
    "schemaVersion": 1006,
    "oldestForwardsCompatibleVersion": 1001,
    "tsdocConfig": {
      "$schema": "https://developer.microsoft.com/json-schemas/tsdoc/v0/tsdoc.schema.json",
      "noStandardTags": true,
      "tagDefinitions": [
        {
          "tagName": "@alpha",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@beta",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@defaultValue",
          "syntaxKind": "block"
        },
        {
          "tagName": "@decorator",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@deprecated",
          "syntaxKind": "block"
        },
        {
          "tagName": "@eventProperty",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@example",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@experimental",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@inheritDoc",
          "syntaxKind": "inline"
        },
        {
          "tagName": "@internal",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@label",
          "syntaxKind": "inline"
        },
        {
          "tagName": "@link",
          "syntaxKind": "inline",
          "allowMultiple": true
        },
        {
          "tagName": "@override",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@packageDocumentation",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@param",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@privateRemarks",
          "syntaxKind": "block"
        },
        {
          "tagName": "@public",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@readonly",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@remarks",
          "syntaxKind": "block"
        },
        {
          "tagName": "@returns",
          "syntaxKind": "block"
        },
        {
          "tagName": "@sealed",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@see",
          "syntaxKind": "block"
        },
        {
          "tagName": "@throws",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@typeParam",
          "syntaxKind": "block",
          "allowMultiple": true
        },
        {
          "tagName": "@virtual",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@betaDocumentation",
          "syntaxKind": "modifier"
        },
        {
          "tagName": "@internalRemarks",
          "syntaxKind": "block"
        },
        {
          "tagName": "@preapproved",
          "syntaxKind": "modifier"
        }
      ],
      "supportForTags": {
        "@alpha": true,
        "@beta": true,
        "@defaultValue": true,
        "@decorator": true,
        "@deprecated": true,
        "@eventProperty": true,
        "@example": true,
        "@experimental": true,
        "@inheritDoc": true,
        "@internal": true,
        "@label": true,
        "@link": true,
        "@override": true,
        "@packageDocumentation": true,
        "@param": true,
        "@privateRemarks": true,
        "@public": true,
        "@readonly": true,
        "@remarks": true,
        "@returns": true,
        "@sealed": true,
        "@see": true,
        "@throws": true,
        "@typeParam": true,
        "@virtual": true,
        "@betaDocumentation": true,
        "@internalRemarks": true,
        "@preapproved": true
      },
      "reportUnsupportedHtmlElements": false
    }
  },
  "kind": "Package",
  "canonicalReference": "prsc!",
  "docComment": "",
  "name": "prsc",
  "members": [
    {
      "kind": "EntryPoint",
      "canonicalReference": "prsc!",
      "name": "",
      "members": [
        {
          "kind": "Function",
          "canonicalReference": "prsc!codepoint:function(1)",
          "docComment": "/**\n * Creates a Parser that skips the next code point if the given predicate returns true.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * To match a sequence of code points, consider using `codepoints` instead.\n *\n * @param isMatch - callback called with the next codepoint, should return whether that matches\n *\n * @param expected - expected strings to return if the codepoint does not match\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function codepoint(isMatch: "
            },
            {
              "kind": "Content",
              "text": "(codepoint: number) => boolean"
            },
            {
              "kind": "Content",
              "text": ", expected: "
            },
            {
              "kind": "Content",
              "text": "string[]"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "isMatch",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            },
            {
              "parameterName": "expected",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "isOptional": false
            }
          ],
          "name": "codepoint"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!codepoints:function(1)",
          "docComment": "/**\n * Creates a Parser that skips code points while the given predicate returns true.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * This acts like `starConsumed(codepoint(isMatch, []))` if expected is not set, or as `plusConsumed(codepoint(isMatch, expected))` if it is, but is much more efficient than either of those combinations.\n *\n * @param isMatch - callback called for each codepoint, should return whether that matches\n *\n * @param expected - expected strings to return if the first codepoint does not match\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function codepoints(isMatch: "
            },
            {
              "kind": "Content",
              "text": "(codepoint: number) => boolean"
            },
            {
              "kind": "Content",
              "text": ", expected?: "
            },
            {
              "kind": "Content",
              "text": "string[]"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "isMatch",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            },
            {
              "parameterName": "expected",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "isOptional": true
            }
          ],
          "name": "codepoints"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!collect:function(1)",
          "docComment": "/**\n * Helper to collect both the yielded values and the returned value from a generator.\n *\n * @param gen - Generator to collect from\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function collect<T, R>(gen: "
            },
            {
              "kind": "Reference",
              "text": "Generator",
              "canonicalReference": "!Generator:interface"
            },
            {
              "kind": "Content",
              "text": "<T, R>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Content",
              "text": "[T[], R]"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "gen",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "R",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "collect"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!complete:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given parser and only succeeds (returning the inner parser's result) if parsing concludes at the end of the input string.\n *\n * @param parser - The parser to wrap\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function complete<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "complete"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!consume:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given parser but discards the resulting value.\n *\n * @param parser - Parser to apply\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function consume<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "consume"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!cut:function(1)",
          "docComment": "/**\n * Creates a Parser that turns errors returned by the inner parser into fatal errors. Parsers such as `or` and `star` will not continue to attempt additional matches if a parser returns a fatal error, and will usually return the error instead.\n *\n * @param parser - The parser to wrap\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function cut<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "cut"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!delimited:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given parsers in sequence, returning the result value of the middle parser at the offset of the third if all are successful. If any parser fails, the error is returned as-is.\n *\n * Optionally makes errors by the second and third parsers fatal if `cutAfterOpen` is `true`.\n *\n * @param open - First parser to apply, value is discarded\n *\n * @param inner - Second parser to apply, value is kept\n *\n * @param close - Third parser to apply, value is discarded\n *\n * @param cutAfterOpen - If `true`, errors returned by the second and third parsers are considered fatal, causing parsers using this to stop trying other branches.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function delimited<TOpen, T, TClose>(open: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<TOpen>"
            },
            {
              "kind": "Content",
              "text": ", inner: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ", close: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<TClose>"
            },
            {
              "kind": "Content",
              "text": ", cutAfterOpen?: "
            },
            {
              "kind": "Content",
              "text": "boolean"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 12,
            "endIndex": 14
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "open",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            },
            {
              "parameterName": "inner",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "isOptional": false
            },
            {
              "parameterName": "close",
              "parameterTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 9
              },
              "isOptional": false
            },
            {
              "parameterName": "cutAfterOpen",
              "parameterTypeTokenRange": {
                "startIndex": 10,
                "endIndex": 11
              },
              "isOptional": true
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "TOpen",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "TClose",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "delimited"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!dispatch:function(1)",
          "docComment": "/**\n * Creates a parser that looks at a single codepoint to determine which parser to invoke. Can be used as an alternative to large `or` parsers if looking ahead can narrow down the options.\n *\n * Can optionally look ahead further than the current codepoint, which is useful when nesting several `dispatch` parsers.\n *\n * @param mapping - Object mapping code points to parsers\n *\n * @param otherwise - Parser to use when the code point is not found in the mapping, or undefined to reject in that situation.\n *\n * @param extraOffset - How far ahead to look for the codepoint, defaults to 0\n *\n * @param expected - Expected values for parse errors generated when there is no codepoint or when the codepoint is not in the mapping and there is no `otherwise` parser\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function dispatch<T>(mapping: "
            },
            {
              "kind": "Content",
              "text": "{\n    [codepoint: number]: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>;\n}"
            },
            {
              "kind": "Content",
              "text": ", otherwise: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T> | undefined"
            },
            {
              "kind": "Content",
              "text": ", extraOffset?: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ", expected?: "
            },
            {
              "kind": "Content",
              "text": "string[]"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 12,
            "endIndex": 14
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "mapping",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 4
              },
              "isOptional": false
            },
            {
              "parameterName": "otherwise",
              "parameterTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 7
              },
              "isOptional": false
            },
            {
              "parameterName": "extraOffset",
              "parameterTypeTokenRange": {
                "startIndex": 8,
                "endIndex": 9
              },
              "isOptional": true
            },
            {
              "parameterName": "expected",
              "parameterTypeTokenRange": {
                "startIndex": 10,
                "endIndex": 11
              },
              "isOptional": true
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "dispatch"
        },
        {
          "kind": "Variable",
          "canonicalReference": "prsc!end:var",
          "docComment": "/**\n * A parser that only succeeds if the end of the input string is reached.\n *\n * @param input - The input to match in\n *\n * @param offset - The offset in `input` at which to start matching\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "end: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            }
          ],
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "end",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!error:function(1)",
          "docComment": "/**\n * Creates an unsuccessful ParseResult (parse error) at the given offset.\n *\n * @param offset - The offset in the input at which matching failed\n *\n * @param expected - An array of strings indicating things that were expected at offset\n *\n * @param fatal - If true, no other branches should be tried as a result of this error\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function error<T>(offset: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ", expected: "
            },
            {
              "kind": "Content",
              "text": "string[]"
            },
            {
              "kind": "Content",
              "text": ", fatal?: "
            },
            {
              "kind": "Content",
              "text": "boolean"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "ParseResult",
              "canonicalReference": "prsc!ParseResult:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 7,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "offset",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            },
            {
              "parameterName": "expected",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "isOptional": false
            },
            {
              "parameterName": "fatal",
              "parameterTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 6
              },
              "isOptional": true
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "error"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!except:function(1)",
          "docComment": "/**\n * Creates a Parser that matches only if the first Parser matches input at the starting position, but the second Parser does not.\n *\n * @param match - Parser that should match\n *\n * @param except - Parser that should not match\n *\n * @param expected - Expected values for parse errors generated when the except parser succeeds\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function except<T, U>(match: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ", except: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<U>"
            },
            {
              "kind": "Content",
              "text": ", expected: "
            },
            {
              "kind": "Content",
              "text": "string[]"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 9,
            "endIndex": 11
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "match",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            },
            {
              "parameterName": "except",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "isOptional": false
            },
            {
              "parameterName": "expected",
              "parameterTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 8
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "U",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "except"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!filter:function(1)",
          "docComment": "/**\n * Creates a Parser that uses the given filter predicate to check values generated by the given parser. Values that pass the predicate are passed through, those that don't return a parse error instead.\n *\n * @param parser - Parser to filter\n *\n * @param filter - Predicate function over the inner parser's values\n *\n * @param expected - Expected values for parse errors generated when the filter rejects a value\n *\n * @param fatal - Whether the error returned when the filter rejects should be fatal\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function filter<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ", filter: "
            },
            {
              "kind": "Content",
              "text": "(v: T) => boolean"
            },
            {
              "kind": "Content",
              "text": ", expected: "
            },
            {
              "kind": "Content",
              "text": "string[]"
            },
            {
              "kind": "Content",
              "text": ", fatal?: "
            },
            {
              "kind": "Content",
              "text": "boolean"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 10,
            "endIndex": 12
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            },
            {
              "parameterName": "filter",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "isOptional": false
            },
            {
              "parameterName": "expected",
              "parameterTypeTokenRange": {
                "startIndex": 6,
                "endIndex": 7
              },
              "isOptional": false
            },
            {
              "parameterName": "fatal",
              "parameterTypeTokenRange": {
                "startIndex": 8,
                "endIndex": 9
              },
              "isOptional": true
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "filter"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!filterUndefined:function(1)",
          "docComment": "/**\n * Creates a parser that discards undefined values from the array produced by the given parser.\n *\n * Useful in combination with `star`, `or` and `consume`:\n * ```\n * const a: Parser<string> = token('a');\n * const b: Parser<void> = consume(token('b'));\n * const abs: Parser<(string | void)[]> = star(or<string | void>([a, b]));\n * const as: Parser<string[]> = filterUndefined(abs);\n * ```\n *\n * @param parser - Parser to apply, should produce an array that may contain undefined entries.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function filterUndefined<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<(T | void)[]>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T[]>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "filterUndefined"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!first:function(1)",
          "docComment": "/**\n * Returns the first of the given two arguments. Useful as a `join` function for `then`. See also `followed`.\n *\n * @param x - Argument to return\n *\n * @param y - Argument to ignore\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function first<T1, T2>(x: "
            },
            {
              "kind": "Content",
              "text": "T1"
            },
            {
              "kind": "Content",
              "text": ", y: "
            },
            {
              "kind": "Content",
              "text": "T2"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Content",
              "text": "T1"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "x",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            },
            {
              "parameterName": "y",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T1",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "T2",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "first"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!followed:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result value of the first at the offset of the second if both succeed. If either parser fails the error is returned as-is.\n *\n * Equivalent to `then(parser, after, first)`.\n *\n * @param parser - First parser to apply, value is kept\n *\n * @param before - Second parser to apply, value is discarded\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function followed<T, TAfter>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ", after: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<TAfter>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 7,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            },
            {
              "parameterName": "after",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "TAfter",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "followed"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!map:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given function to each value generated by the given parser.\n *\n * @param parser - Parser to map over\n *\n * @param map - Function to transform values generated by parser\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function map<T, U>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ", map: "
            },
            {
              "kind": "Content",
              "text": "(v: T) => U"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<U>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            },
            {
              "parameterName": "map",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "U",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "map"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!not:function(1)",
          "docComment": "/**\n * Creates a Parser that succeeds at the starting offset if the given parser fails and vice-versa.\n *\n * @param parser - The parser to apply\n *\n * @param expected - Expected values for parse errors generated when the inner parser succeeds\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function not<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ", expected: "
            },
            {
              "kind": "Content",
              "text": "string[]"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            },
            {
              "parameterName": "expected",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "not"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!ok:function(1)",
          "docComment": "/**\n * Creates a successful ParseResult with an undefined value. Use this to signal success in cases where no value is required.\n *\n * @param offset - The offset in the input at which to continue parsing\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function ok(offset: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "ParseResult",
              "canonicalReference": "prsc!ParseResult:type"
            },
            {
              "kind": "Content",
              "text": "<undefined>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "offset",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "name": "ok"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!okWithValue:function(1)",
          "docComment": "/**\n * Creates a successful ParseResult containing the given value.\n *\n * @param offset - The offset in the input at which to continue parsing\n *\n * @param value - The value resulting from applying the parser\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function okWithValue<T>(offset: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ", value: "
            },
            {
              "kind": "Content",
              "text": "T"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "ParseResult",
              "canonicalReference": "prsc!ParseResult:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 7
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "offset",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            },
            {
              "parameterName": "value",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "okWithValue"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!optional:function(1)",
          "docComment": "/**\n * Creates a Parser that tries to apply the given parser optionally. It returns the inner parser's result if succesful, and otherwise indicates success at the starting offset with a `null` value.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @param parser - Parser to attempt to apply\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function optional<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T | null>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "optional"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!or:function(1)",
          "docComment": "/**\n * Creates a Parser that applies each of the given parsers in turn until one matches, then returns that parser's result. If no parser matches, an error is returned reflecting the furthest offset reached in the input string. If any parser returns a fatal error, no further branches are tried.\n *\n * @param parsers - Parsers to attempt to apply\n *\n * @param expected - Overrides the expected value used if none of the inner parsers match\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function or<T>(parsers: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>[]"
            },
            {
              "kind": "Content",
              "text": ", expected?: "
            },
            {
              "kind": "Content",
              "text": "string[]"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 6,
            "endIndex": 8
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parsers",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            },
            {
              "parameterName": "expected",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 5
              },
              "isOptional": true
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "or"
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "prsc!Parser:type",
          "docComment": "/**\n * A parser is a function that tries to match whatever it expects at the given offset in the input string. Returns a ParseResult.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare type Parser<T> = "
            },
            {
              "kind": "Content",
              "text": "(input: string, offset: number) => "
            },
            {
              "kind": "Reference",
              "text": "ParseResult",
              "canonicalReference": "prsc!ParseResult:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "releaseTag": "Public",
          "name": "Parser",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 4
          }
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "prsc!ParseResult:type",
          "docComment": "/**\n * The result of parsing - either success (with an offset at which to resume parsing the next thing) or failure. If a failure is fatal, parsing should not continue to try alternative options.\n *\n * A ParseResult may contain a value that represents the parsed input.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare type ParseResult<T> = "
            },
            {
              "kind": "Content",
              "text": "{\n    success: true;\n    offset: number;\n    value: T;\n} | {\n    success: false;\n    offset: number;\n    expected: string[];\n    fatal: boolean;\n}"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "releaseTag": "Public",
          "name": "ParseResult",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 2
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!peek:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given parser without consuming any input. That is, if the inner parser is successful, success is returned (with the resulting value) at the starting offset, effectively making the parser consume no input.\n *\n * Errors returned by the inner parser are returned as-is.\n *\n * @param parser - The parser to apply, value is discarded and any progress made in input is reset.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function peek<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "peek"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!plus:function(1)",
          "docComment": "/**\n * Creates a Parser that tries to apply the given parser one or more times in sequence. Values for successful matches are collected in an array. Once the inner parser no longer matches, success is returned at the offset reached with the accumulated values. The parser is required to match at least once, so an initial failure is returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @param parser - The parser to apply repeatedly\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function plus<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T[]>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "plus"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!plusConsumed:function(1)",
          "docComment": "/**\n * Creates a Parser that tries to apply the given parser one or more times in sequence. Values for successful matches are discarded. Once the inner parser no longer matches, success is returned at the offset reached. The parser is required to match at least once, so an initial failure is returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @param parser - The parser to apply repeatedly\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function plusConsumed<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "plusConsumed"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!preceded:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result of the second if the first succeeds.\n *\n * Equivalent to `then(before, parser, second)`.\n *\n * @param before - First parser to apply, value is discarded\n *\n * @param parser - Second parser to apply, value is kept\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function preceded<TBefore, T>(before: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<TBefore>"
            },
            {
              "kind": "Content",
              "text": ", parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 7,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "before",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            },
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "TBefore",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "preceded"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!range:function(1)",
          "docComment": "/**\n * Creates a Parser that matches a single character from a range of codepoints.\n *\n * Use `recognize` if you need the character that was matched.\n *\n * @param firstCodePoint - The first code point to accept\n *\n * @param lastCodePoint - The last code point to accept (inclusive)\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function range(firstCodePoint: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ", lastCodePoint: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": ", expected?: "
            },
            {
              "kind": "Content",
              "text": "string[]"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 7,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "firstCodePoint",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            },
            {
              "parameterName": "lastCodePoint",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "isOptional": false
            },
            {
              "parameterName": "expected",
              "parameterTypeTokenRange": {
                "startIndex": 5,
                "endIndex": 6
              },
              "isOptional": true
            }
          ],
          "name": "range"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!recognize:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given parser. If successful, the inner parser's value is discarded and the substring that was consumed from the input is returned as value instead. Errors are returned as-is.\n *\n * When using this in combination with `star` or `plus`, consider using `starConsumed` or `plusConsumed` instead for efficiency.\n *\n * @param parser - The parser to apply, value is discarded and replaced by the consumed input.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function recognize<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<string>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "recognize"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!second:function(1)",
          "docComment": "/**\n * Returns the second of the given two arguments. Useful as a `join` function for `then`. See also `preceded`.\n *\n * @param x - Argument to ignore\n *\n * @param y - Argument to return\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function second<T1, T2>(x: "
            },
            {
              "kind": "Content",
              "text": "T1"
            },
            {
              "kind": "Content",
              "text": ", y: "
            },
            {
              "kind": "Content",
              "text": "T2"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Content",
              "text": "T2"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 5,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "x",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            },
            {
              "parameterName": "y",
              "parameterTypeTokenRange": {
                "startIndex": 3,
                "endIndex": 4
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T1",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "T2",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "second"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!skipChars:function(1)",
          "docComment": "/**\n * Creates a Parser that skips the given number of characters.\n *\n * This counts in unicode characters (code points), not UTF-16 code units.\n *\n * @param nCodepoints - number of characters to skip\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function skipChars(nCodepoints: "
            },
            {
              "kind": "Content",
              "text": "number"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "nCodepoints",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "name": "skipChars"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!star:function(1)",
          "docComment": "/**\n * Creates a Parser that tries to apply the given parser zero or more times in sequence. Values for successful matches are collected in an array. Once the inner parser no longer matches, success is returned at the offset reached with the accumulated values.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @param parser - Parser to apply repeatedly\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function star<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T[]>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "star"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!starConsumed:function(1)",
          "docComment": "/**\n * Creates a Parser that tries to apply the given parser zero or more times in sequence. Values for successful matches are discarded. Once the inner parser no longer matches, success is returned at the offset reached.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @param parser - Parser to apply repeatedly\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function starConsumed<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "starConsumed"
        },
        {
          "kind": "Variable",
          "canonicalReference": "prsc!start:var",
          "docComment": "/**\n * A parser that only succeeds at the start of the input string.\n *\n * @param input - The input to match in\n *\n * @param offset - The offset in `input` at which to start matching\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "start: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<void>"
            }
          ],
          "isReadonly": true,
          "releaseTag": "Public",
          "name": "start",
          "variableTypeTokenRange": {
            "startIndex": 1,
            "endIndex": 3
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!streaming:function(1)",
          "docComment": "/**\n * Creates a StreamingParser which applies the given Parser and yields the value produced if it matches.\n *\n * @param parser - The Parser to apply\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function streaming<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "StreamingParser",
              "canonicalReference": "prsc!StreamingParser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "streaming"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!streamingComplete:function(1)",
          "docComment": "/**\n * Creates a StreamingParser that applies the given parser and directly yields values produced by it, and then only succeeds if parsing concludes at the end of the input string.\n *\n * @param parser - StreamingParser to apply\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function streamingComplete<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "StreamingParser",
              "canonicalReference": "prsc!StreamingParser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "StreamingParser",
              "canonicalReference": "prsc!StreamingParser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "streamingComplete"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!streamingFilterUndefined:function(1)",
          "docComment": "/**\n * Creates a StreamingParser which discards undefined values yielded by the given StreamingParser.\n *\n * @param parser - The StreamingParser to filter\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function streamingFilterUndefined<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "StreamingParser",
              "canonicalReference": "prsc!StreamingParser:type"
            },
            {
              "kind": "Content",
              "text": "<T | void>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "StreamingParser",
              "canonicalReference": "prsc!StreamingParser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "streamingFilterUndefined"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!streamingOptional:function(1)",
          "docComment": "/**\n * Creates a StreamingParser that tries to apply the given parser optionally. It only yields the values produced by the inner parser if it matches successfully, and does not yield anything otherwise.\n *\n * @param parser - StreamingParser to attempt to apply\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function streamingOptional<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "StreamingParser",
              "canonicalReference": "prsc!StreamingParser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "StreamingParser",
              "canonicalReference": "prsc!StreamingParser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "streamingOptional"
        },
        {
          "kind": "TypeAlias",
          "canonicalReference": "prsc!StreamingParser:type",
          "docComment": "/**\n * A StreamingParser is similar to a Parser, but instead of returning a value when parsing is complete it can parse incrementally and yield values as they are produced. The generator returns a ParseResult when iteration is done which indicates whether parsing was successful.\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare type StreamingParser<T> = "
            },
            {
              "kind": "Content",
              "text": "(input: string, offset: number) => "
            },
            {
              "kind": "Reference",
              "text": "Generator",
              "canonicalReference": "!Generator:interface"
            },
            {
              "kind": "Content",
              "text": "<T, "
            },
            {
              "kind": "Reference",
              "text": "ParseResult",
              "canonicalReference": "prsc!ParseResult:type"
            },
            {
              "kind": "Content",
              "text": "<unknown>>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "releaseTag": "Public",
          "name": "StreamingParser",
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "typeTokenRange": {
            "startIndex": 1,
            "endIndex": 6
          }
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!streamingStar:function(1)",
          "docComment": "/**\n * Creates a StreamingParser that tries to apply the given StreamingParser zero or more times in sequence. Values produced during each iteration are only yielded whenever the inner parser matches successfully.\n *\n * @param parser - StreamingParser to apply repeatedly\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function streamingStar<T>(parser: "
            },
            {
              "kind": "Reference",
              "text": "StreamingParser",
              "canonicalReference": "prsc!StreamingParser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "StreamingParser",
              "canonicalReference": "prsc!StreamingParser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 4,
            "endIndex": 6
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "streamingStar"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!streamingThen:function(1)",
          "docComment": "/**\n * Creates a StreamingParser which applies the given two StreamingParsers in sequence.\n *\n * Unlike `then`, this does not combine values using a function, but instead simply yields the values produced by both parsers as they produce them.\n *\n * @param parser1 - First StreamingParser to apply\n *\n * @param parser2 - StreamingParser to apply if the first one is successful\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function streamingThen<T, U>(parser1: "
            },
            {
              "kind": "Reference",
              "text": "StreamingParser",
              "canonicalReference": "prsc!StreamingParser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ", parser2: "
            },
            {
              "kind": "Reference",
              "text": "StreamingParser",
              "canonicalReference": "prsc!StreamingParser:type"
            },
            {
              "kind": "Content",
              "text": "<U>"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "StreamingParser",
              "canonicalReference": "prsc!StreamingParser:type"
            },
            {
              "kind": "Content",
              "text": "<T | U>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 7,
            "endIndex": 9
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser1",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            },
            {
              "parameterName": "parser2",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "U",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "streamingThen"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!then:function(1)",
          "docComment": "/**\n * Creates a Parser that applies the given two parsers in sequence, returning success only if both succeed. The given join function is used to combine the values from both parsers into the single value to return. If either parser fails, the failure is returned as-is.\n *\n * @param parser1 - First parser to apply\n *\n * @param parser2 - Parser to apply after the first one is successful\n *\n * @param join - Function used to combine the values of both parsers\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function then<T1, T2, T>(parser1: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T1>"
            },
            {
              "kind": "Content",
              "text": ", parser2: "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T2>"
            },
            {
              "kind": "Content",
              "text": ", join: "
            },
            {
              "kind": "Content",
              "text": "(value1: T1, value2: T2) => T"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<T>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 9,
            "endIndex": 11
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "parser1",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 3
              },
              "isOptional": false
            },
            {
              "parameterName": "parser2",
              "parameterTypeTokenRange": {
                "startIndex": 4,
                "endIndex": 6
              },
              "isOptional": false
            },
            {
              "parameterName": "join",
              "parameterTypeTokenRange": {
                "startIndex": 7,
                "endIndex": 8
              },
              "isOptional": false
            }
          ],
          "typeParameters": [
            {
              "typeParameterName": "T1",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "T2",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            },
            {
              "typeParameterName": "T",
              "constraintTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              },
              "defaultTypeTokenRange": {
                "startIndex": 0,
                "endIndex": 0
              }
            }
          ],
          "name": "then"
        },
        {
          "kind": "Function",
          "canonicalReference": "prsc!token:function(1)",
          "docComment": "/**\n * Creates a Parser that matches the given string.\n *\n * @param token - The expected string\n *\n * @public\n */\n",
          "excerptTokens": [
            {
              "kind": "Content",
              "text": "export declare function token(token: "
            },
            {
              "kind": "Content",
              "text": "string"
            },
            {
              "kind": "Content",
              "text": "): "
            },
            {
              "kind": "Reference",
              "text": "Parser",
              "canonicalReference": "prsc!Parser:type"
            },
            {
              "kind": "Content",
              "text": "<string>"
            },
            {
              "kind": "Content",
              "text": ";"
            }
          ],
          "returnTypeTokenRange": {
            "startIndex": 3,
            "endIndex": 5
          },
          "releaseTag": "Public",
          "overloadIndex": 1,
          "parameters": [
            {
              "parameterName": "token",
              "parameterTypeTokenRange": {
                "startIndex": 1,
                "endIndex": 2
              },
              "isOptional": false
            }
          ],
          "name": "token"
        }
      ]
    }
  ]
}
